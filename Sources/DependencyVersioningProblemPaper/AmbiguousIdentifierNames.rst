
Resolving Ambiguous Function and Type Names
-------------------------------------------

As soon as we start to use two versions of one library in the same dependency tree we will have name clashes because
both libraries declare and define mostly the same entities. C++ introduced namespaces to solve name clashes between
different libraries. So I use them here as well. We will get source files that look like this:

.. code-block:: C++

	// File MyFunction.h
	#pragma once

	namespace dvpLibC_1_0_0
	{
		void myFunction();
	}

The depicted file would be for version ``1.0.0``. When we upgrade to version ``2.0.0`` we will need to change the
namespace to ``dvpLibC_2_0_0``.

As you can imagine, changing the namespace by hand every time we make a commit, would be a very expensive and error prone solution.
Also we still have the problem that the version name may not be available before the commit in all code versioning systems.

My first approach was to simply use a preprocessor definition to replace a version agnostic name in the source file with
one that contains the version. The file would then look like this:

.. code-block:: C++

	// File MyFunction.h
	#pragma once

	namespace dvpLibC
	{
		void myFunction();
	}

We would compile this with a compiler option that would look something like ``/D dvpLibC=dvpLibC_1_0_0`` that would define the
``dvpLibC`` macro to expand to ``dvpLibC_1_0_0`` during compilation. This works all fine until a (indirect) consumer of libC needs to include the
headers of both library versions in one ``.cpp`` file. At this moment we can no longer distinguish between the names come from
``dvpLibC_1_0_0`` and ``dvpLibC_2_0_0`` because we have only one macro that we can replace.

So we need a way to replace that macro per header and not globally as a compiler option does. I managed to make this work by
relying on the special behavior of the algorithm that the compiler uses to search for included files. `msvc`, `clang` and `gcc`
will all look first in the directory that contains the currently preprocessed file. Exploiting this behavior, we can 
provide another header file ``dvpLibCDependencyNames.h`` that contains the definition of the ``dvpLibC`` macro.
The file is generated by the build system to remove all need for manual work. It looks like this:


.. code-block:: C++

	// dvpLibCDependencyNames.h
	#undef dvpLibC
	#define dvpLibC dvpLibC_1_0_0

This file must now be included in ``MyFunction.h`` before using the ``dvpLibC`` macro.


.. code-block:: C++

	// File MyFunction.h
	#pragma once

	// This should always be resolved to the file that is parallel to MyFunction.h
	#include "dvpLibCDependencyNames.h"	

	namespace dvpLibC
	{
		void myFunction();
	}


If a client now includes headers from ``dvpLibC_1_0_0`` and ``dvpLibC_2_0_0`` in one file 

.. code-block:: C++

	// client.cpp
	// Includes will be hidden deep in the include tree.
	#include <dvpLibC_1_0_0/MyFunction.h>
	#include <dvpLibC_2_0_0/MyFunction.h>

the preprocessor will expand the includes in an intermediate step to this:

.. code-block:: C++

	// client.cpp

	#undef dvpLibC
	#define dvpLibC dvpLibC_1_0_0

	namespace dvpLibC
	{
		void myFunction();
	}

	#undef dvpLibC
	#define dvpLibC dvpLibC_2_0_0

	namespace dvpLibC
	{
		void myFunction();
	}

As we can see, the declarations are now wrapped in the correct *versioned* namespaces.
While this works now, relying on the internals of the include search algorithm of the compiler
is fragile and may break in the future.


